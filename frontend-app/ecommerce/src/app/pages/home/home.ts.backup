import { Component, OnInit, inject, signal, PLATFORM_ID, ViewChild, ElementRef, AfterViewInit } from '@angular/core';
import { CommonModule, isPlatformBrowser } from '@angular/common';
import { RouterLink } from '@angular/router';
import { DomSanitizer, SafeResourceUrl } from '@angular/platform-browser';
import { ApiService } from '../../services/api.service';
import { StatsCardComponent } from '../../components/stats-card/stats-card.component';
import { Stats } from '../../models/stats.model';
import { Chart, ChartConfiguration, registerables } from 'chart.js';

// Register Chart.js components
Chart.register(...registerables);

@Component({
  selector: 'app-home',
  standalone: true,
  imports: [CommonModule, RouterLink, StatsCardComponent],
  templateUrl: './home.html'
})
export class Home implements OnInit, AfterViewInit {
  private apiService = inject(ApiService);
  private platformId = inject(PLATFORM_ID);
  private sanitizer = inject(DomSanitizer);
  
  @ViewChild('transactionsChart') transactionsChartRef?: ElementRef<HTMLCanvasElement>;
  @ViewChild('errorsChart') errorsChartRef?: ElementRef<HTMLCanvasElement>;
  
  stats = signal<Stats | null>(null);
  loading = signal(true);
  error = signal<string | null>(null);
  connectionStatus = signal<string>('Connecting...');
  
  private transactionsChart?: Chart;
  private errorsChart?: Chart;
  
  // Kibana dashboard URL
  kibanaDashboardUrl: SafeResourceUrl;

  constructor() {
    // Sanitize the Kibana dashboard URL - 5 weeks time range
    const dashboardUrl = 'http://localhost:5601/app/dashboards#/view/baed2430-d360-11f0-8cc1-e14176d70d6e?embed=true&_g=(filters:!(),refreshInterval:(pause:!t,value:60000),time:(from:now-5w,to:now))';
    this.kibanaDashboardUrl = this.sanitizer.bypassSecurityTrustResourceUrl(dashboardUrl);
  }

  ngOnInit() {
    // Only make API calls in the browser, not during SSR
    if (isPlatformBrowser(this.platformId)) {
      this.loadStats();
      this.checkHealth();
    } else {
      this.loading.set(false);
      this.connectionStatus.set('Server-side rendering...');
    }
  }

  ngAfterViewInit() {
    // Charts will be created after stats are loaded
  }

  loadStats() {
    this.loading.set(true);
    this.apiService.getStats().subscribe({
      next: (data) => {
        this.stats.set(data);
        this.loading.set(false);
        // Create charts after stats are loaded
        setTimeout(() => this.createCharts(), 100);
      },
      error: (err) => {
        this.error.set('Failed to load statistics');
        this.loading.set(false);
        console.error('Error loading stats:', err);
      }
    });
  }

  checkHealth() {
    this.apiService.healthCheck().subscribe({
      next: (response) => {
        this.connectionStatus.set(response.message || 'Connected');
      },
      error: () => {
        this.connectionStatus.set('API Connection Error');
      }
    });
  }

  refresh() {
    this.loadStats();
    this.checkHealth();
  }

  createCharts() {
    if (!isPlatformBrowser(this.platformId)) {
      console.log('âš ï¸ Not in browser, skipping charts');
      return;
    }
    
    const stats = this.stats();
    if (!stats) {
      console.log('âš ï¸ No stats available');
      return;
    }

    console.log('âœ… Creating charts with stats:', stats);
    console.log('ðŸ“Š Transactions data:', stats.transactionsPerHour);
    console.log('ðŸ“Š Errors data:', stats.errorsByType);
    
    this.createTransactionsChart(stats);
    this.createErrorsChart(stats);
  }

  createTransactionsChart(stats: Stats) {
    console.log('ðŸ“ˆ Creating transactions chart...');
    
    if (!this.transactionsChartRef) {
      console.log('âš ï¸ transactionsChartRef is not available');
      return;
    }
    
    // Destroy existing chart
    if (this.transactionsChart) {
      this.transactionsChart.destroy();
    }

    const ctx = this.transactionsChartRef.nativeElement.getContext('2d');
    if (!ctx) {
      console.log('âš ï¸ Cannot get 2d context');
      return;
    }

    const labels = stats.transactionsPerHour.map(t => t.label);
    const data = stats.transactionsPerHour.map(t => t.value);
    
    console.log('ðŸ“Š Transactions labels:', labels);
    console.log('ðŸ“Š Transactions data:', data);

    const config: ChartConfiguration = {
      type: 'line',
      data: {
        labels: labels,
        datasets: [{
          label: 'Transactions par heure',
          data: data,
          borderColor: 'rgb(59, 130, 246)',
          backgroundColor: 'rgba(59, 130, 246, 0.1)',
          tension: 0.4,
          fill: true,
          pointRadius: 4,
          pointHoverRadius: 6
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: true,
            position: 'top'
          },
          tooltip: {
            mode: 'index',
            intersect: false
          }
        },
        scales: {
          y: {
            beginAtZero: true,
            title: {
              display: true,
              text: 'Nombre de transactions'
            }
          },
          x: {
            title: {
              display: true,
              text: 'Heure'
            }
          }
        }
      }
    };

    this.transactionsChart = new Chart(ctx, config);
    console.log('âœ… Transactions chart created successfully');
  }

  createErrorsChart(stats: Stats) {
    console.log('ðŸ”´ Creating errors chart...');
    
    if (!this.errorsChartRef) {
      console.log('âš ï¸ errorsChartRef is not available');
      return;
    }
    
    // Destroy{
      console.log('âš ï¸ Cannot get 2d context for errors chart');
      return;
    }

    const labels = stats.errorsByType.map(e => e.label);
    const data = stats.errorsByType.map(e => e.value);
    
    console.log('ðŸ“Š Errors labels:', labels);
    console.log('ðŸ“Š Errors data:', data

    const ctx = this.errorsChartRef.nativeElement.getContext('2d');
    if (!ctx) return;

    const labels = stats.errorsByType.map(e => e.label);
    const data = stats.errorsByType.map(e => e.value);

    const config: ChartConfiguration = {
      type: 'pie',
      data: {
        labels: labels,
        datasets: [{
          data: data,
          backgroundColor: [
            'rgba(239, 68, 68, 0.8)',
            'rgba(251, 146, 60, 0.8)',
            'rgba(234, 179, 8, 0.8)',
            'rgba(59, 130, 246, 0.8)',
            'rgba(139, 92, 246, 0.8)'
          ],
          borderColor: [
            'rgb(239, 68, 68)',
            'rgb(251, 146, 60)',
            'rgb(234, 179, 8)',
            'rgb(59, 130, 246)',
            'rgb(139, 92, 246)'
          ],
          borderWidth: 2
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: true,
            position: 'right'
          },
          tooltip: {
            callbacks: {
              label: (context: any) => {
                const label = context.label || '';
                const value = context.parsed || 0;
                const dataset = context.dataset;
                const total = dataset.data.reduce((sum: number, val: any) => {
                  return sum + (typeof val === 'number' ? val : 0);
                }, 0);
                const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : '0';
                return `${label}: ${value} (${percentage}%)`;
              }
            }
    console.log('âœ… Errors chart created successfully');
          }
        }
      }
    };

    this.errorsChart = new Chart(ctx, config);
  }

  ngOnDestroy() {
    if (this.transactionsChart) {
      this.transactionsChart.destroy();
    }
    if (this.errorsChart) {
      this.errorsChart.destroy();
    }
  }
}
